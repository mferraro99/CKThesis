# This is a script for the estimation of ΔH0f(0 K) based on the Connectivity Based Hierarchy method
# The code covers three CBH levels (Isogyric-CBH0, Isodesmic-CBH1, Hypomodesmotic-CBH2)

# The code needs a working rdkit environment in order to compute the connectivity of the molecule

# The code does not require canonical SMILES definition in the database
# Every form of well defined SMILES is accepted by the code ([CH2]CC and CC[CH2] are both valide reference species SMILES)

# This is a post-processing code -> Needs a computed simulation with es2k
# The ΔH0f(0 K) is estimated at the highest level possible: if both level1 and HL simulation results are present,
# two different ΔH0f(0 K) will be estimated, while if only level1 results are present, one ΔH0f(0 K) will be estimated

# The results files are stored in the "thermo" directory, while only the numerical results, in [Ha], are stored in the "output"
# and "me_files" directories for level1 and HL estimations, respectively

'''
################################################################ IMPORTANT !!!! ##############################################################################
# For the construction of the rung0, rung1 and rung2 reactions, the InChI and SMILES identificators are needed. The SMILES is obtained from the conversion of
# the InChI identificator found in "/data/name.dat". "name.dat" is automatically generated if inchi_to_data is used for setting "data" directory
# If "data" is set up differently, "name.dat" must be generated by hand, including only the correct InChI
##############################################################################################################################################################
'''

import os
import sys
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem import PeriodicTable

# Define path for level1 and hl reference file
directory_level1 = "/g100/home/userexternal/mferrar2/python_codes/cbh/cbh_reffile.dat"
directory_hl = "/g100/home/userexternal/mferrar2/python_codes/cbh/HL_cbh_reffile.dat"

# Define the directory in which the database file for CBH 0-1-2 fragments is stored (level1)
with open(directory_level1) as lines: reference = lines.readlines()

# Check if thermo directory is already present
# False: thermo non present -> Create
# True: thermo already present -> Don't create
thermo_directory = False

try:
    os.chdir("thermo")
    os.chdir("..")
    thermo_directory = True
except:
    pass

# Determine the level of theory for estimation
with open("data/theory.dat") as theoryfile:
    lines = theoryfile.readlines()
    for string_pos in range(len(lines)):
        if "level1" in lines[string_pos]:
            pos_lot = string_pos+1
            break

if "wb97xd/jun-cc-pvtz" in lines[pos_lot]:
    lot = 1
    lot_string = "wb97xd/jun-cc-pvtz" # Level1, omegab97

elif "b2plypd3/jun-cc-pvtz" in lines[pos_lot]:
    lot = 2
    lot_string = "b2plypd3/jun-cc-pvtz" # Level2, b2plypd3

elif "REV" in lines[pos_lot]:
    lot = 3
    lot_string = "REV" # Level3, REV

else: # If the lot does not correspond to any of the database lot, the computation is interrupted
    if not thermo_directory:
        os.mkdir("thermo")
        thermo_directory = True
    os.chdir("thermo")
    text = "ERROR: the computed level of theory found in 'data/theory.dat' does not correspond to any reference level of theory.\n"+\
           "The computation with different levels of theory leads to erroneous ΔH0f(0 K) estimations.\n"+\
           "Change level of theory in order to have a reliable estimation or check syntax of theory.dat."
    error = open("DH0K_failed","w")
    error.write(text)
    error.close()
    sys.exit() # Stop the estimation procedure due to lack of suitable level of theory

lot += 1 # Takes into account the database file formatting, no relation with the lot used

CBH0,CBH1,CBH2 = {},{},{}

# Extract the starting lines of every level reference species -> Ending line is represented by a SINGLE blank line for every set
# "Heavy" keyword defines the heavy atom involved in the calculations (default C,O,N) -> Can be changed if other ref. species are added
for line in range(len(reference)):
    line_splitted = reference[line].replace("\n","").split()
    if line_splitted != [] and line_splitted[0] == "Heavy": species_line = line
    if line_splitted != [] and line_splitted[0] == "CBH0": CBH0_start = line
    if line_splitted != [] and line_splitted[0] == "CBH1": CBH1_start = line
    if line_splitted != [] and line_splitted[0] == "CBH2":
        CBH2_start = line
        break

# Definition of CBH0 dictionary, contatining for every ref. species [N , Eel+ZPE @lot selected , DH0f(0 K) @lot selected]
# The keyword associated is the SMILES contained in the database -> Doesn't need to be in canonical form!
# N is the number of times the species is included in the rung 0 reaction (set=0 as starting point)
for line in range(CBH0_start+1,CBH1_start-1):
    species = reference[line].replace("\n","").split()
    CBH0[species[1]]=[0,species[lot],species[5]]

# Definition of CBH0 dictionary, contatining for every ref. species [N , Eel+ZPE @lot selected , DH0f(0 K) @lot selected]
# The keyword associated is the SMILES contained in the database -> Doesn't need to be in canonical form!
# N is the number of times the species is included in the rung 1 reaction (set=0 as starting point)
for line in range(CBH1_start+1,CBH2_start-1):
    species = reference[line].replace("\n","").split()
    CBH1[species[1]]=[0,species[lot],species[5]]

# Definition of CBH0 dictionary, contatining for every ref. species [N , Eel+ZPE @lot selected , DH0f(0 K) @lot selected]
# The keyword associated is the SMILES contained in the database -> Doesn't need to be in canonical form!
# N is the number of times the species is included in the rung 2 reaction (set=0 as starting point)
for line in range(CBH2_start+1,len(reference)):
    species = reference[line].replace("\n","").split()
    CBH2[species[1]]=[0,species[lot],species[5]]

saturation,atoms_right,atoms_left = {},{},{}

# Extraction and setting of the heavy atoms property (saturation) from the reference file
line_splitted = reference[species_line].replace("\n","").split()
ptable = Chem.GetPeriodicTable()
for atom in range(2,len(line_splitted)):
    saturation[line_splitted[atom]] = ptable.GetValenceList(line_splitted[atom])[0]

    # This definition is useful for rung 1, in which, due to terminal moieties, we have cancellation of some reactants_rung1 (which are products_rung0)
    atoms_right[line_splitted[atom]] = [0,0] # First counter for non radical heavy atoms, second counter for radicals. Products side
    atoms_left[line_splitted[atom]] = [0,0] # First counter for non radical heavy atoms, second counter for radicals. Reactants side

# Opens name.dat and extract InChI identificator
inchi = []
with open("data/name.dat") as lines:
    names = lines.readlines()
    inchi.append(names[0].strip())
    inchi = inchi[0]

HL_computed = False
try: # The high level has been computed -> We can estimate DH0 at level1 and also at HL
    with open("me_files/reac1_en.me") as en:
        line = en.readlines()
        line = line[0].strip("\n").replace(" ","")
        energyHL = float(line)
    with open("geoms/reac1_l1.xyz") as en:
        line = en.readlines()
        line = line[1].strip("\n").replace(" ","")
        energy = float(line)
    HL_computed = True

except: # The high level has not been computed -> We can estimate DH0 only at level1

    try:
        with open("geoms/reac1_l1.xyz") as en:
            line = en.readlines()
            line = line[1].strip("\n").replace(" ","")
            energy = float(line)

    except: # Both level1 and Hl failed -> Can't compute DH0f
        if not thermo_directory:
            os.mkdir("thermo")
            thermo_directory = True
        os.chdir("thermo")
        text_failedl1 = "ERROR: level 1 has not been computed.\nCan not estimate ΔH0f(0 K)."
        error = open("DH0K_failed","w")
        error.write(text_failedl1)
        error.close()
        sys.exit() # Stop the estimation procedure due to lack of level 1 simulation infos

# Extract the value of zero point energy
with open("me_files/reac1_zpe.me") as zpe_file:
    line = zpe_file.readlines()
    line = line[0].strip("\n").replace(" ","")
    zpe = float(line)

# Level1 energy_el+ZPE is calculated
E = energy + zpe
# High level energy_el+ZPE is calculated
if HL_computed: EHL = energyHL + zpe

# If HL estimation is possible, a twin file with HL data is opened and the same procedure for level1 estimation data is repeated
if HL_computed:
    # Define the directory in which the database file for CBH 0-1-2 fragments is stored (HL)
    with open(directory_hl) as lines: reference = lines.readlines()

    CBH0hl,CBH1hl,CBH2hl = {},{},{}
    for line in range(len(reference)):
        line_splitted = reference[line].replace("\n","").split()
        if line_splitted != [] and line_splitted[0] == "Heavy": species_line = line
        if line_splitted != [] and line_splitted[0] == "CBH0": CBH0_start = line
        if line_splitted != [] and line_splitted[0] == "CBH1": CBH1_start = line
        if line_splitted != [] and line_splitted[0] == "CBH2":
            CBH2_start = line
            break
    for line in range(CBH0_start+1,CBH1_start-1):
        species = reference[line].replace("\n","").split()
        CBH0hl[species[1]]=[0,species[lot],species[5]]

    for line in range(CBH1_start+1,CBH2_start-1):
        species = reference[line].replace("\n","").split()
        CBH1hl[species[1]]=[0,species[lot],species[5]]

    for line in range(CBH2_start+1,len(reference)):
        species = reference[line].replace("\n","").split()
        CBH2hl[species[1]]=[0,species[lot],species[5]]

#Generate mol element, adding hydrogens, and SMILES identificator
mol = Chem.inchi.MolFromInchi(inchi)
smiles = Chem.MolToSmiles(mol)
mol = Chem.AddHs(mol)
Chem.Kekulize(mol) # Convert the mol file in a kekulized mole file -> Used for aromatics DH0f(0 K) estimation

#----------------------------------------------------------------------------------------------------------------------------------------------------
'''CBH0 level -> Every heavy atom is saturated with hydrogens and a correct amount of hydrogen molecules is added
   reactant side to balance the hydrogens'''

H_in_molecule = 0 # Keeps track of how many hydrogens are present in the molecule
is_radical = False # Check for radical

atom_in_mol = [] # Used to keep track of the position of the atom, assigned by rdkit (useful for CBH1 and CBH2)
H_inproducts = 0 # Count how many hydrogens we have products side

for atom in range(mol.GetNumAtoms()):# Cycle all the atoms in the molecule

    symbol = mol.GetAtomWithIdx(atom).GetSymbol() # Define atomic symbol
    atom_in_mol.append(mol.GetAtomWithIdx(atom).GetSymbol()) # Assign at position "atom" (number) the atomic symbol of atom_i

    if mol.GetAtomWithIdx(atom).GetSymbol() != "H": # Add and check for radical only if the atom is not an hydrogen
        if mol.GetAtomWithIdx(atom).GetNumRadicalElectrons() == 0:
            CBH0[symbol][0] +=1 # Increase the number of atoms of type i (non radicals) products side

            # Add to the right counter of H the saturation of type i atom (ex for Carbon, 4 is added; for Oxygen, 2 is added; for Nitrogen, 3 is added)
            H_inproducts = H_inproducts + saturation[mol.GetAtomWithIdx(atom).GetSymbol()]

            #!See below for explanation!
            atoms_right[mol.GetAtomWithIdx(atom).GetSymbol()][0] += 2
        else:

            is_radical = True # The molecule is radical

            #!See below for explanation!
            atoms_right[mol.GetAtomWithIdx(atom).GetSymbol()][1] += 2

            if saturation[mol.GetAtomWithIdx(atom).GetSymbol()]-1 > 1:
                # Increase the number of atoms of type i (radicals) products side by proper definition of the SMILES
                CBH0["["+mol.GetAtomWithIdx(atom).GetSymbol()+"H"+str(saturation[mol.GetAtomWithIdx(atom).GetSymbol()]-1)+"]"][0] += 1
                # Update H counter
                H_inproducts = H_inproducts + saturation[mol.GetAtomWithIdx(atom).GetSymbol()]-1 # Ex. [CH3], the counter is increased by (saturation_C)-1 = 4-1 = 3

            elif saturation[mol.GetAtomWithIdx(atom).GetSymbol()]-1 == 1:
                # Increase the number of atoms of type i (radicals) products side by proper definition of the SMILES
                CBH0["["+mol.GetAtomWithIdx(atom).GetSymbol()+"H]"][0] += 1
                # Update H counter
                H_inproducts = H_inproducts + saturation[mol.GetAtomWithIdx(atom).GetSymbol()]-1
            else:
                CBH0["["+mol.GetAtomWithIdx(atom).GetSymbol()+"]"][0] += 1

    else: H_in_molecule += 1 # Increase hydrogen counter in the molecule of 1 since the atom i is an hydrogen

#######
# atoms_right - atoms_left explanation:
# Since the reactants for rung 1 reaction are the products of rung 0 + original molecule, the total number of heavy atoms (radical or non-radical) on reactants side, rung 1,
# will be two times the heavy atoms contained in the original molecule, so the counter is +2 for each heavy atoms. The products of rung 1 retain the immediate environment
# in terms of bonds (i.e., OC=N will create O + OC + C=N + N). The O and N are added due to the presence of a "dummy" bond (with no species) on left side of O and right side
# of N (terminal moieties treatment). Of course O and N will be present also in the reactants side rung1 (because they are products of rung0), so a species cancellation is needed.
# By counting how many heavy atoms (and which type, radical or not) are present before computing products side rung1, and computing how many heavy atoms we would have products rung 1 side,
# the number of heavy atoms that should be added/removed from left side is determined.
# If ramifications are present, it might be the case in which atoms are added on left side rung 1, but this is automatically taken into account by the difference (with sign) atoms_right - atoms_left
#######

# Calculate how many H2 are needed to balance the equation at CBH0
H2_saturate = int(1/2*(H_inproducts - H_in_molecule))

sumDH0_prod, sumE_prod = 0,0

# Estimation of DH0f at rung 0 for level 1
for key in CBH0: # Calculate the sum of DH0f and sum of (Eel+ZPE) for products rung 0
    if CBH0[key][0] != 0:
        sumDH0_prod += float(CBH0[key][2])*float(CBH0[key][0])
        sumE_prod += float(CBH0[key][1])*float(CBH0[key][0])

DH_reaz = (sumE_prod - H2_saturate*float(CBH0["[HH]"][1]) - E) # Calculate the DH of reaction
DH0_rung0 = -DH_reaz + (sumDH0_prod) # Estimate the DH0f(0 K) at rung 0, level 1

if HL_computed: # If the high level is computed, every operation for level 1 is repeated with high level reference data

    # The counter for every hl reference species is set equal to the corresponding counter for level1 species
    # No need to redo all the computations
    for key in CBH0:
        for keyhl in CBH0hl:
            if key == keyhl:
                CBH0hl[keyhl][0] = CBH0[key][0]
                break

    sumDH0_prod, sumE_prod = 0,0

    for key in CBH0hl:
        if CBH0hl[key][0] != 0:
            sumDH0_prod += float(CBH0hl[key][2])*float(CBH0hl[key][0])
            sumE_prod += float(CBH0hl[key][1])*float(CBH0hl[key][0])

    DH_reaz = (sumE_prod - H2_saturate*float(CBH0hl["[HH]"][1]) - EHL)
    DH0_rung0_HL = -DH_reaz + (sumDH0_prod)

###########
# Output file construction:

# Construction of the products string ( i SMILES_1 + j SMILES_2 + ...), i,j = " ",2,3,4 ...
# The construction is equivalent for both level 1 and hl
product_CBH0 = []
for key in CBH0:
    if CBH0[key][0] != 0:
        if CBH0[key][0] > 1: product_CBH0.append(str(CBH0[key][0])+" "+key)
        else: product_CBH0.append(key)

string_product0 = " + ".join(product_CBH0)

# Construction of reaction rung 0 string
if H2_saturate > 1: reaction0 = smiles + " + "+str(int(H2_saturate))+" [H][H] --> "+string_product0
else: reaction0 = smiles + " + "+"[H][H] --> "+string_product0

# Important: for reasons of terminal moieties/ramifications, the counter done in rung 0 is stored, while CBH0 will change
# in rung 1 construction for the determination of reactants rung 1
CBH0_old = CBH0

# Assume rung 0 is not computed (molecule too short, ex CH4) -> Worst case scenario
flag_CBH0 = False

# Store the reference species for output file in the form: (SMILES) (Eel+ZPE) (DH0f)
# This is updated at every rung, in order to have a reference list in the output file
infos = ""

for key in CBH0_old:
    if CBH0_old[key][0] != 0:

        # If at least one ref. species is found in rung 0 products, rung 0 has been computed -> Turn flag_CBH0 True
        if key != smiles: flag_CBH0 = True

        # Formatting (Eel+ZPE)
        if float(CBH0_old[key][1]) > -100.0: line="{:<15}{:>5}".format(key, str(CBH0_old[key][1]))
        else: line="{:<14}{:>5}".format(key, str(CBH0_old[key][1]))

        # Formatting DH0f
        if float(CBH0_old[key][2]) > 0: infos = infos+line +"    "+ str(CBH0_old[key][2]) +"\n"
        else: infos = infos+line +"   "+ str(CBH0_old[key][2]) +"\n"

if HL_computed:
    CBH0hl_old = CBH0hl
    infoshl = ""
    for key in CBH0:
        if CBH0hl_old[key][0] != 0:
            # Formatting (Eel+ZPE)
            if float(CBH0hl_old[key][1]) > -100.0: line="{:<15}{:>5}".format(key, str(CBH0hl_old[key][1]))
            else: line="{:<14}{:>5}".format(key, str(CBH0hl_old[key][1]))

            # Formatting DH0f
            if float(CBH0hl_old[key][2]) > 0: infoshl = infoshl+line +"    "+ str(CBH0hl_old[key][2]) +"\n"
            else: infoshl = infoshl+line +"   "+ str(CBH0hl_old[key][2]) +"\n"

###########

#----------------------------------------------------------------------------------------------------------------------------------------------------
'''CBH1 level -> The bonds are preserved with every information (bond type, atoms forming the bond, type of atoms (radicals or not)).
Terminal moieties and ramifications are treated separately'''

# The number of bonds every heavy atom forms (with another heavy atom) will be stored to be used in rung 2 construction
# C-C is counted, while C-H is not counted
n_bonds = [0]*int(mol.GetNumAtoms())

# The type of enumeration given by rdkit is not known a priori, so a smart nested loop is used to identify if atom_i is bonded to atom_k

for atom_i in range(mol.GetNumAtoms()):
    for atom_k in range(atom_i,mol.GetNumAtoms()):

        # Bond identified + atom_i and atom_k are not hydrogens
        if mol.GetBondBetweenAtoms(atom_i, atom_k) != None and \
            mol.GetAtomWithIdx(atom_i).GetSymbol() !="H" and mol.GetAtomWithIdx(atom_k).GetSymbol() !="H":

            # Increase the bond counter for atom_i and atom_k
            n_bonds[atom_i] += 1
            n_bonds[atom_k] += 1

            # The symbol associated with the type of bond is saved, along the number of electrons that every atom should use to form the bond
            # The second information is used for proper construction of the species SMILES
            bond = []
            if str(mol.GetBondBetweenAtoms(atom_i, atom_k).GetBondType()) == "SINGLE": bond =["",1]
            elif str(mol.GetBondBetweenAtoms(atom_i, atom_k).GetBondType()) == "DOUBLE": bond =["=",2]
            else: bond =["#",3]

            # The symbols of both atoms are determined and the individual SMILES are constructed, accoarding to the saturation and bond number
            atoms =[atom_i,atom_k]
            symbols =[]
            for atom in atoms:

                if mol.GetAtomWithIdx(atom).GetNumRadicalElectrons() == 0:
                    # The atom is not a radical, the symbol is the atomic number (C or O or N)
                    symbols.append(mol.GetAtomWithIdx(atom).GetSymbol())
                    # The counter of non-radical heavy atom on products side rung 1 is increased by one -> Used for final definition of reactants rung 1
                    atoms_left[mol.GetAtomWithIdx(atom).GetSymbol()][0] += 1

                else:
                    if saturation[mol.GetAtomWithIdx(atom).GetSymbol()]-bond[1]-1 > 1:
                        # The atom is a radical and the total number of hydrogens (considering the electrons for the bond) is greater than 1
                        # The corresponding SMILES is, ex for a C* with single bond, [CH2]. With a double bond it would be [CH]
                        symbols.append("["+mol.GetAtomWithIdx(atom).GetSymbol()+"H"+ \
                        str(saturation[mol.GetAtomWithIdx(atom).GetSymbol()]-bond[1]-1)+"]")

                    elif saturation[mol.GetAtomWithIdx(atom).GetSymbol()]-bond[1]-1 == 1:
                        # The atom is a radical and the total number of hydrogens (considering the electrons for the bond) is equal to 1
                        # The corresponding SMILES is not [CH1], but [CH]
                        symbols.append("["+mol.GetAtomWithIdx(atom).GetSymbol()+"H]")

                    else:
                        # The atom is a radical and the total number of hydrogens (considering the electrons for the bond) is equal to 0
                        # The corresponding SMILES is [C]
                        symbols.append("["+mol.GetAtomWithIdx(atom).GetSymbol()+"]")

                    # The counter of radical heavy atom on products side rung 1 is increased by one -> Used for final definition of reactants rung 1
                    atoms_left[mol.GetAtomWithIdx(atom).GetSymbol()][1] += 1

            # The counter for the final species, composed by SMILES1+bond+SMILES2, is increased
            # The implementation is straightforward because the structure of a three atoms SMILES is well defined:
            # (Symbol_SMILES_A)(Symbol_bondType)(Symbol_SMILES_B) or (Symbol_SMILES_B)(Symbol_bondType)(Symbol_SMILES_A)
            try: CBH1[symbols[0]+bond[0]+symbols[1]][0] += 1
            except: CBH1[symbols[1]+bond[0]+symbols[0]][0] += 1

# Store the rung 1 CBH1 counter, because it will be updated in rung 2 construction
CBH1_old = CBH1
# Flag to determine if rung 1 has been computed
flag_CBH1 = False

# The counter for every hl reference species is set equal to the corresponding counter for level1 species
# No need to redo all the computations
if HL_computed:
    for key in CBH1:
        for keyhl in CBH1hl:
            if key == keyhl:
                CBH1hl[keyhl][0] = CBH1[key][0]
                break
    CBH1hl_old = CBH1hl

# Update the reference species informations for level1 and hl
for key in CBH1_old:
    if CBH1_old[key][0] != 0:
        if float(CBH1_old[key][1]) > -100.0: line="{:<15}{:>5}".format(key, str(CBH1_old[key][1]))
        else: line="{:<14}{:>5}".format(key, str(CBH1_old[key][1]))
        if float(CBH1_old[key][2]) > 0: infos = infos+line +"    "+ str(CBH1_old[key][2]) +"\n"
        else: infos = infos+line +"   "+ str(CBH1_old[key][2]) +"\n"

if HL_computed:
    for key in CBH1hl_old:
        if CBH1hl_old[key][0] != 0:
            if float(CBH1hl_old[key][1]) > -100.0: line="{:<15}{:>5}".format(key, str(CBH1hl_old[key][1]))
            else: line="{:<14}{:>5}".format(key, str(CBH1hl_old[key][1]))
            if float(CBH1hl_old[key][2]) > 0: infoshl = infoshl+line +"    "+ str(CBH1hl_old[key][2]) +"\n"
            else: infoshl = infoshl+line +"   "+ str(CBH1hl_old[key][2]) +"\n"

# The reactants of rung 1 are now adjusted on the basis of the balance between heavy atoms products-reactants side
# Radical and non-radical species are treated separately (C is different from C*)
# 1) atoms_right_i_j = number of heavy atoms of type i (radical/non-radical) present in j number on reactants side rung 1 BEFORE species cancellation
# 2) atoms_left_i_k = number of heavy atoms of type i (radical/non-radical) present in k number on products side rung 1 resulting from previous nested loop
# Three situations arise:
# A) atoms_right_i_j - atoms_left_i_k > 0 : there are too many atoms_i on reactants rung 1 side; reactant i should be decreased by a quantity equal to |atoms_right_i_j - atoms_left_i_k|
# B) atoms_right_i_j - atoms_left_i_k < 0 : there are too many atoms_i on products rung 1 side; reactant i should be increased by a quantity equal to |atoms_right_i_j - atoms_left_i_k|
# C) atoms_right_i_j - atoms_left_i_k = 0 : the number of atoms is perfectly balanced, no action nedeed

for symbol_i in atoms_left:

    if atoms_right[symbol_i][0] - atoms_left[symbol_i][0] != 0: # For non-radical species
        CBH0[symbol_i][0] = CBH0[symbol_i][0] - (atoms_right[symbol_i][0] - atoms_left[symbol_i][0])

    if atoms_right[symbol_i][1] - atoms_left[symbol_i][1] != 0: # For radical species
        if saturation[symbol_i]-1 > 1:
            CBH0["["+symbol_i+"H"+str(saturation[symbol_i]-1)+"]"][0] = \
                CBH0["["+symbol_i+"H"+str(saturation[symbol_i]-1)+"]"][0] - (atoms_right[symbol_i][1] - atoms_left[symbol_i][1])
        elif saturation[symbol_i]-1 == 1:
            CBH0["["+symbol_i+"H]"][0] = CBH0["["+symbol_i+"H]"][0] - (atoms_right[symbol_i][1] - atoms_left[symbol_i][1])
        else:
            CBH0["["+symbol_i+"]"][0] = CBH0["["+symbol_i+"]"][0] - (atoms_right[symbol_i][1] - atoms_left[symbol_i][1])

# CBH0hl (high level) is updated on the basis of CBH0 modifications
if HL_computed:
    for key in CBH0:
        for keyhl in CBH0hl:
            if key == keyhl:
                CBH0hl[keyhl][0] = CBH0[key][0]
                break

# Construction of the products string ( i SMILES_1 + j SMILES_2 + ...), i,j = " ",2,3,4 ...
# The construction is equivalent for both level 1 and hl
product_CBH1 = []
for key in CBH1:
    if CBH1[key][0] != 0:
        if key != smiles:
            flag_CBH1= True
            flag_CBH0= False
        if CBH1[key][0] > 1: product_CBH1.append(str(CBH1[key][0])+" "+key)
        else: product_CBH1.append(key)

# Construction of the reactants string ( i SMILES_1 + j SMILES_2 + ...), i,j = " ",2,3,4 ...
# The construction is equivalent for both level 1 and hl
reactant_CBH1 = []
for key in CBH0:
    if CBH0[key][0] != 0:
        if CBH0[key][0] > 1: reactant_CBH1.append(str(CBH0[key][0])+" "+key)
        else: reactant_CBH1.append(key)

string_reactant1 = " + ".join(reactant_CBH1)
string_product1 = " + ".join(product_CBH1)

# Construction of the reaction string
reaction1 = smiles + " + "+ string_reactant1+" --> "+string_product1

sumDH0_prod, sumDH0_reac, sumE_prod, sumE_reac = 0,0,0,0

# Estimation of DH0f at rung 1, level 1
# Products sum of (Eel+ZPE) and sum of DH0f
for key in CBH0:
    if CBH0[key][0] != 0:
        sumDH0_reac += float(CBH0[key][2])*float(CBH0[key][0])
        sumE_reac += float(CBH0[key][1])*float(CBH0[key][0])

# Reactants sum of (Eel+ZPE) and sum of DH0f
for key in CBH1:
    if CBH1[key][0] != 0:
        sumDH0_prod += float(CBH1[key][2])*float(CBH1[key][0])
        sumE_prod += float(CBH1[key][1])*float(CBH1[key][0])


DH_reaz = (sumE_prod - sumE_reac - E) # DH of reaction
DH0_rung1 = -DH_reaz + (sumDH0_prod - sumDH0_reac) # DH0f

# Estimation of DH0f at rung 1, high level
if HL_computed:
    sumDH0_prod, sumDH0_reac, sumE_prod, sumE_reac = 0,0,0,0

    # Products sum of (Eel+ZPE) and sum of DH0f
    for key in CBH0hl:
        if CBH0hl[key][0] != 0:
            sumDH0_reac += float(CBH0hl[key][2])*float(CBH0hl[key][0])
            sumE_reac += float(CBH0hl[key][1])*float(CBH0hl[key][0])

    # Reactants sum of (Eel+ZPE) and sum of DH0f
    for key in CBH1hl:
        if CBH1hl[key][0] != 0:
            sumDH0_prod += float(CBH1hl[key][2])*float(CBH1hl[key][0])
            sumE_prod += float(CBH1hl[key][1])*float(CBH1hl[key][0])

    DH_reaz = (sumE_prod - sumE_reac - EHL) # DH of reaction
    DH0_rung1_HL = -DH_reaz + (sumDH0_prod - sumDH0_reac) # DH0f

#----------------------------------------------------------------------------------------------------------------------------------------------------
'''CBH2 level -> The immediate surrounding environment of every atom is preserved with every information
(bond type, atoms forming the bond, type of atoms (radicals or not)).
Terminal moieties and ramifications are treated separately'''

# Due to the presence of terminal moieties and ramifications, and because the products of rung 1 are the reactants of rung 2
# some addition/cancellation of species is needed (as done in rung 1). This is accomplished by modification of the dictionary CBH1
# by definition of terminal moieties SMILES equivalent to rung 1 products definition

# Define a list in which reference species not present in the database will be saved, throwing a warning in the output file, if at least one is found
# This is necessary due the complexity of CBH2 reference set (up to 5 heavy atoms)
smilesnotfound = []

for atom_i in range(mol.GetNumAtoms()): # Cycle through all atoms

    # An heavy atom forming only one bond with another heavy atom is a terminal moiety
    if n_bonds[atom_i] == 1:
        for atom_j in range(mol.GetNumAtoms()): # Search for the heavy atom forming the bond with atom_i, both non-H
            if mol.GetBondBetweenAtoms(atom_i, atom_j) != None and \
                mol.GetAtomWithIdx(atom_i).GetSymbol() !="H" and mol.GetAtomWithIdx(atom_j).GetSymbol() !="H":

                # The construction of the SMILES follows the same procedure used for products of rung 1
                # Definition of bond symbol and number of electrons of every atom involved
                bond = []
                if str(mol.GetBondBetweenAtoms(atom_i, atom_j).GetBondType()) == "SINGLE": bond =["",1]
                elif str(mol.GetBondBetweenAtoms(atom_i, atom_j).GetBondType()) == "DOUBLE": bond =["=",2]
                else: bond =["#",3]

                atoms =[atom_i,atom_j]
                symbols =[]
                for atom in atoms:
                    # Non-radical species, symbol = atomic symbol ex. C
                    if mol.GetAtomWithIdx(atom).GetNumRadicalElectrons() == 0:
                        symbols.append(mol.GetAtomWithIdx(atom).GetSymbol())

                    else:
                        # Number of H higher than 1, symbol like [CH3]
                        if saturation[mol.GetAtomWithIdx(atom).GetSymbol()]-bond[1]-1 > 1:
                            symbols.append("["+mol.GetAtomWithIdx(atom).GetSymbol()+"H"+ \
                                           str(saturation[mol.GetAtomWithIdx(atom).GetSymbol()]-bond[1]-1)+"]")

                        # Number of H equal to 1, symbol like [CH]
                        elif saturation[mol.GetAtomWithIdx(atom).GetSymbol()]-bond[1]-1 == 1:
                            symbols.append("["+mol.GetAtomWithIdx(atom).GetSymbol()+"H]")

                        # Number of H equal to 0, symbol like [C]
                        else:
                            symbols.append("["+mol.GetAtomWithIdx(atom).GetSymbol()+"]")

                # Only two possible SMILES form
                # (Symbol_SMILES_A)(Symbol_bondType)(Symbol_SMILES_B) or (Symbol_SMILES_B)(Symbol_bondType)(Symbol_SMILES_A)
                # Since the CBH1 reference species are easily collected, the SMILES will be found in the database in every case
                try: CBH1[symbols[0]+bond[0]+symbols[1]][0] -= 1
                except: CBH1[symbols[1]+bond[0]+symbols[0]][0] -= 1

    # Atom_i forms two bonds with two different heavy atoms (ex. CCC)
    if n_bonds[atom_i] == 2:
        for atom_j in range(mol.GetNumAtoms()):
            if mol.GetBondBetweenAtoms(atom_i, atom_j) != None and \
                mol.GetAtomWithIdx(atom_i).GetSymbol() !="H" and mol.GetAtomWithIdx(atom_j).GetSymbol() !="H":
                for atom_k in range(atom_j,mol.GetNumAtoms()):
                    if mol.GetBondBetweenAtoms(atom_i, atom_k) != None and atom_j != atom_k and mol.GetAtomWithIdx(atom_k).GetSymbol() !="H":

                        # Find two different atom_j and atom_k, non-H, bonded to atom_i, with nested loops
                        atoms = [atom_i,atom_j,atom_k]

                        # Define the two bonds atom_i-atom_j and atom_i-atom_k in terms of symbols and electron involved
                        bond = {}
                        for i in range(1,len(atoms)):
                            if str(mol.GetBondBetweenAtoms(atom_i, atoms[i]).GetBondType()) == "SINGLE": bond[i]=["",1]
                            elif str(mol.GetBondBetweenAtoms(atom_i, atoms[i]).GetBondType()) == "DOUBLE": bond[i]=["=",2]
                            else: bond[i]=["#",3]

                        # Calculate the total number of electrons shared in bonds by atom_i, atom_j and atom_k
                        # This will be used for counting the number of hydrogens bonded to every atom and so the SMILES construction
                        remove_saturation = [bond[1][1]+bond[2][1],bond[1][1],bond[2][1]]
                        symbols = []

                        for index in range(len(atoms)):
                            # Non-radical species, symbol equal to atomic symbol ex. C
                            if mol.GetAtomWithIdx(atoms[index]).GetNumRadicalElectrons() == 0:
                                symbols.append(mol.GetAtomWithIdx(atoms[index]).GetSymbol())
                            else:
                                # Number of H higher than 1, symbol of the type [CH3]
                                if saturation[mol.GetAtomWithIdx(atoms[index]).GetSymbol()]-remove_saturation[index]-1 > 1:
                                    symbols.append("["+mol.GetAtomWithIdx(atoms[index]).GetSymbol()+"H"+ \
                                                   str(saturation[mol.GetAtomWithIdx(atoms[index]).GetSymbol()] - remove_saturation[index]-1)+"]")

                                # Number of H equal to 1, symbol of the type [CH]
                                elif saturation[mol.GetAtomWithIdx(atoms[index]).GetSymbol()]-remove_saturation[index]-1 == 1:
                                    symbols.append("["+mol.GetAtomWithIdx(atoms[index]).GetSymbol()+"H]")

                                # Number of H equal to 0, symbol of the type [C]
                                else:
                                    symbols.append("["+mol.GetAtomWithIdx(atoms[index]).GetSymbol()+"]")

                        # The syntax of a three atoms SMILES is well defined and there are only two possible forms
                        # regarding the evaluation of the environment of atom_i (which is in any case the central atom)
                        # (Symbol_SMILES_j)(Symbol_bond_ij)(Symbol_SMILES_i)(Symbol_bond_ik)(Symbol_SMILES_k) or
                        # (Symbol_SMILES_k)(Symbol_bond_ik)(Symbol_SMILES_i)(Symbol_bond_ij)(Symbol_SMILES_j)
                        try:
                            try: CBH2[symbols[1]+bond[1][0]+symbols[0]+bond[2][0]+symbols[2]][0] += 1
                            except: CBH2[symbols[2]+bond[2][0]+symbols[0]+bond[1][0]+symbols[1]][0] += 1
                        except:
                            # If the reference species is not present in the database, a warning message is computed,
                            # along with a list of the SMILES not found in the database
                            smilesnotfound.append(symbols[1]+bond[1][0]+symbols[0]+bond[2][0]+symbols[2])

    # Atom_i forms three bonds with three different heavy atoms (ex. CC(C)C)
    if n_bonds[atom_i] == 3:
        for atom_j in range(mol.GetNumAtoms()):
            if mol.GetBondBetweenAtoms(atom_i, atom_j) != None and \
                mol.GetAtomWithIdx(atom_i).GetSymbol() !="H" and mol.GetAtomWithIdx(atom_j).GetSymbol() !="H":
                for atom_k in range(atom_j,mol.GetNumAtoms()):
                    if mol.GetBondBetweenAtoms(atom_i, atom_k) != None and \
                        atom_j != atom_k and atom_k != atom_i and mol.GetAtomWithIdx(atom_k).GetSymbol() !="H":
                        for atom_x in range(atom_k,mol.GetNumAtoms()):
                            if mol.GetBondBetweenAtoms(atom_i, atom_x) != None and \
                                atom_x != atom_k and atom_x != atom_j and atom_x!=atom_i and mol.GetAtomWithIdx(atom_x).GetSymbol() !="H":

                                # Find three different atom_j, atom_k and atom_x, non-H, bonded to atom_i, with nested loops
                                atoms = [atom_i,atom_j,atom_k,atom_x]

                                # Define the three bonds atom_i-atom_j, atom_i-atom_k and atom_i-atom_x in terms of symbols and electron involved
                                bond = {}
                                for i in range(1,len(atoms)):
                                    if str(mol.GetBondBetweenAtoms(atom_i, atoms[i]).GetBondType()) == "SINGLE": bond[i]=["",1]
                                    elif str(mol.GetBondBetweenAtoms(atom_i, atoms[i]).GetBondType()) == "DOUBLE": bond[i]=["=",2]
                                    else: bond[i]=["#",3]

                                # Calculate the total number of electrons shared in bonds by atom_i, atom_j, atom_k and atom_x
                                # This will be used for counting the number of hydrogens bonded to every atom and so the SMILES construction
                                remove_saturation = [bond[1][1]+bond[2][1]+bond[3][1],bond[1][1],bond[2][1],bond[3][1]]
                                symbols = []

                                for index in range(len(atoms)):
                                    # Non-radical species, symbol equal to atomic symbol ex. C
                                    if mol.GetAtomWithIdx(atoms[index]).GetNumRadicalElectrons() == 0:
                                        symbols.append(mol.GetAtomWithIdx(atoms[index]).GetSymbol())

                                    else:
                                        # Number of H higher than 1, symbol of the type [CH3]
                                        if saturation[mol.GetAtomWithIdx(atoms[index]).GetSymbol()]-remove_saturation[index]-1 > 1:
                                            symbols.append("["+mol.GetAtomWithIdx(atoms[index]).GetSymbol()+"H"+ \
                                                           str(saturation[mol.GetAtomWithIdx(atoms[index]).GetSymbol()]-remove_saturation[index]-1)+"]")

                                        # Number of H equal to 1, symbol of the type [CH]
                                        elif saturation[mol.GetAtomWithIdx(atoms[index]).GetSymbol()]-remove_saturation[index]-1 == 1:
                                            symbols.append("["+mol.GetAtomWithIdx(atoms[index]).GetSymbol()+"H]")

                                        # Number of H equal to 0, symbol of the type [C]
                                        else:
                                            symbols.append("["+mol.GetAtomWithIdx(atoms[index]).GetSymbol()+"]")

                                # Save SMILES symbol and bond symbol of atom_i-atom_j/k/x in a single list for simplicity
                                symbol_and_bond = {}
                                for i in range(1,len(symbols)): symbol_and_bond[i] = [symbols[i],bond[i][0]]

                                smiles_found = False # Turns True if the reference SMILES is found in the reference set
                                append_smile = True # Turns false if smiles_found turns True: no need for adding the SMILES in the list of missing SMILES from the database

                                # Even if the general structure of a four atoms SMILES is well defined, the possible arrangements are 3x2x1 = 6
                                # (Symbol_SMILES_k)(Symbol_bond_ik) (Symbol_SMILES_i) ((Symbol_bond_ix)(Symbol_SMILES_x)) (Symbol_bond_ij)(Symbol_SMILES_j)
                                # j,k,x are combinatorily exchanged since the form is not know a priori
                                # Three nested loops checks which is the correct form/if no corresponding SMILES is present
                                for j in range(1,len(symbol_and_bond)+1):
                                    for k in range(1,len(symbol_and_bond)+1):
                                        for x in range(1,len(symbol_and_bond)+1):

                                            if j != k and j != x and x != k:

                                                # Check if the structure found is present in the reference set
                                                if symbol_and_bond[j][0]+symbol_and_bond[j][1]+symbols[0]+"("+symbol_and_bond[k][1]+symbol_and_bond[k][0]+")"+ \
                                                    symbol_and_bond[x][1]+symbol_and_bond[x][0] in CBH2:
                                                    CBH2[symbol_and_bond[j][0]+symbol_and_bond[j][1]+symbols[0]+"("+symbol_and_bond[k][1]+symbol_and_bond[k][0]+")"+ \
                                                         symbol_and_bond[x][1]+symbol_and_bond[x][0]][0]  += 1

                                                    smiles_found = True
                                                    append_smile = False
                                                    # If found, the nested cycles are broken

                                            if smiles_found: break
                                        if smiles_found: break
                                    if smiles_found: break

                                if append_smile: # If append_smile is still True the SMILES is not present in the database (or its equivalent forms)
                                    smilesnotfound.append(symbol_and_bond[1][0]+symbol_and_bond[1][1]+symbols[0]+"("+symbol_and_bond[3][1]+symbol_and_bond[3][0]+")"+ \
                                                          symbol_and_bond[2][1]+symbol_and_bond[2][0])

    # Atom_i forms four bonds with four different heavy atoms (ex. CC(C)(C) C)
    if n_bonds[atom_i] == 4:
        for atom_j in range(mol.GetNumAtoms()):
            if mol.GetBondBetweenAtoms(atom_i, atom_j) != None and \
                mol.GetAtomWithIdx(atom_i).GetSymbol() !="H" and mol.GetAtomWithIdx(atom_j).GetSymbol() !="H":
                for atom_k in range(atom_j,mol.GetNumAtoms()):
                    if mol.GetBondBetweenAtoms(atom_i, atom_k) != None and \
                        atom_j != atom_k and atom_k != atom_i and mol.GetAtomWithIdx(atom_k).GetSymbol() !="H":
                        for atom_x in range(atom_k,mol.GetNumAtoms()):
                            if mol.GetBondBetweenAtoms(atom_i, atom_x) != None and \
                                atom_x != atom_k and atom_x != atom_j and atom_x!=atom_i and mol.GetAtomWithIdx(atom_x).GetSymbol() !="H":
                                for atom_y in range(atom_x,mol.GetNumAtoms()):
                                    if mol.GetBondBetweenAtoms(atom_i, atom_y) != None and \
                                        atom_y != atom_x and atom_y != atom_k and atom_y != atom_j and atom_y!=atom_i and mol.GetAtomWithIdx(atom_y).GetSymbol() !="H":

                                        # Find four different atom_j, atom_k, atom_x and atom_y, non-H, bonded to atom_i, with nested loops
                                        atoms = [atom_i,atom_j,atom_k,atom_x,atom_y]

                                        # Define the four bonds atom_i-atom_j, atom_i-atom_k, atom_i-atom_x and atom_i-atom_y in terms of symbols and electron involved
                                        bond = {}
                                        for i in range(1,len(atoms)):
                                            if str(mol.GetBondBetweenAtoms(atom_i, atoms[i]).GetBondType()) == "SINGLE": bond[i]=["",1]
                                            elif str(mol.GetBondBetweenAtoms(atom_i, atoms[i]).GetBondType()) == "DOUBLE": bond[i]=["=",2]
                                            else: bond[i]=["#",3]

                                        # Calculate the total number of electrons shared in bonds by atom_i, atom_j, atom_k, atom_x and atom_y
                                        # This will be used for counting the number of hydrogens bonded to every atom and so the SMILES construction
                                        remove_saturation = [bond[1][1]+bond[2][1]+bond[3][1]+bond[4][1],bond[1][1],bond[2][1],bond[3][1],bond[4][1]]
                                        symbols = []

                                        for index in range(len(atoms)):

                                            # Non-radical species, symbol equal to atomic symbol ex. C
                                            if mol.GetAtomWithIdx(atoms[index]).GetNumRadicalElectrons() == 0:
                                                symbols.append(mol.GetAtomWithIdx(atoms[index]).GetSymbol())
                                            else:

                                                # Number of H higher than 1, symbol of the type [CH3]
                                                if saturation[mol.GetAtomWithIdx(atoms[index]).GetSymbol()]-remove_saturation[index]-1 > 1:
                                                    symbols.append("["+mol.GetAtomWithIdx(atoms[index]).GetSymbol()+"H"+ \
                                                                   str(saturation[mol.GetAtomWithIdx(atoms[index]).GetSymbol()]-remove_saturation[index]-1)+"]")

                                                # Number of H equal to 1, symbol of the type [CH]
                                                elif saturation[mol.GetAtomWithIdx(atoms[index]).GetSymbol()]-remove_saturation[index]-1 == 1:
                                                    symbols.append("["+mol.GetAtomWithIdx(atoms[index]).GetSymbol()+"H]")

                                                # Number of H equal to 0, symbol of the type [C]
                                                else:
                                                    symbols.append("["+mol.GetAtomWithIdx(atoms[index]).GetSymbol()+"]")

                                        # Save SMILES symbol and bond symbol of atom_i-atom_j/k/x/y in a single list for simplicity
                                        symbol_and_bond = {}
                                        for i in range(1,len(symbols)): symbol_and_bond[i] = [symbols[i],bond[i][0]]

                                        smiles_found = False # Turns True if the reference SMILES is found in the reference set
                                        append_smile = True # Turns false if smiles_found turns True: no need for adding the SMILES in the list of missing SMILES from the database

                                        # Even if the general structure of a five atoms SMILES is well defined, the possible arrangements are 4x3x2x1 = 24
                                        # (Symbol_SMILES_k)(Symbol_bond_ik) (Symbol_SMILES_i) ((Symbol_bond_ix)(Symbol_SMILES_x)) ((Symbol_bond_iy)(Symbol_SMILES_y)) (Symbol_bond_ij)(Symbol_SMILES_j)
                                        # j,k,x,y are combinatorily exchanged since the form is not know a priori
                                        # Four nested loops checks which is the correct form/if no corresponding SMILES is present
                                        for j in range(1,len(symbol_and_bond)+1):
                                            for k in range(1,len(symbol_and_bond)+1):
                                                for x in range(1,len(symbol_and_bond)+1):
                                                    for y in range(1,len(symbol_and_bond)+1):

                                                        if j != k and j != x and j != y and k != x and k != y and x!= y:

                                                            # Check if the structure found is present in the reference set
                                                            if symbol_and_bond[j][0]+symbol_and_bond[j][1]+symbols[0]+"("+symbol_and_bond[k][1]+symbol_and_bond[k][0]+")"+"("+symbol_and_bond[y][1]+symbol_and_bond[y][0]+")"+symbol_and_bond[x][1]+symbol_and_bond[x][0] in CBH2:
                                                                CBH2[symbol_and_bond[j][0]+symbol_and_bond[j][1]+symbols[0]+"("+symbol_and_bond[k][1]+symbol_and_bond[k][0]+")"+"("+symbol_and_bond[y][1]+symbol_and_bond[y][0]+")"+symbol_and_bond[x][1]+symbol_and_bond[x][0]][0] += 1

                                                                # If found, the nested cycles are broken
                                                                smiles_found = True
                                                                append_smile = False

                                                        if smiles_found: break
                                                    if smiles_found: break
                                                if smiles_found: break
                                            if smiles_found: break
                                        if append_smile: # If append_smile is still True the SMILES is not present in the database (or its equivalent forms)
                                            smilesnotfound.append(symbol_and_bond[1][0]+symbol_and_bond[1][1]+symbols[0]+"("+symbol_and_bond[3][1]+symbol_and_bond[3][0]+")"+"("+symbol_and_bond[4][1]+symbol_and_bond[4][0]+")"+symbol_and_bond[2][1]+symbol_and_bond[2][0])

# Construction of the products string ( i SMILES_1 + j SMILES_2 + ...), i,j = " ",2,3,4 ...
# The construction is equivalent for both level 1 and hl
product_CBH2 = []
flag_CBH2 = False

for key in CBH2:
    if CBH2[key][0] != 0:
        if key != smiles and smilesnotfound == []:
            flag_CBH2= True
            flag_CBH1= False
            flag_CBH0= False
        if CBH2[key][0] > 1: product_CBH2.append(str(CBH2[key][0])+" "+key)
        else: product_CBH2.append(key)

# Construction of the reactants string ( i SMILES_1 + j SMILES_2 + ...), i,j = " ",2,3,4 ...
# The construction is equivalent for both level 1 and hl
reactant_CBH2 = []
for key in CBH1:
    if CBH1[key][0] != 0:
        if CBH1[key][0] > 1: reactant_CBH2.append(str(CBH1[key][0])+" "+key)
        else: reactant_CBH2.append(key)

string_reactant2 = " + ".join(reactant_CBH2)
string_product2 = " + ".join(product_CBH2)

# Construction of the reaction string
reaction2 = smiles + " + "+ string_reactant2+" --> "+string_product2

sumDH0_prod, sumDH0_reac, sumE_prod, sumE_reac = 0,0,0,0

# Estimation of DH0f at rung 2, level 1
# Reactants sum of (Eel+ZPE) and sum of DH0f
for key in CBH1:
    if CBH1[key][0] != 0:
        sumDH0_reac += float(CBH1[key][2])*float(CBH1[key][0])
        sumE_reac += float(CBH1[key][1])*float(CBH1[key][0])

# Products sum of (Eel+ZPE) and sum of DH0f
for key in CBH2:
    if CBH2[key][0] != 0:
        sumDH0_prod += float(CBH2[key][2])*float(CBH2[key][0])
        sumE_prod += float(CBH2[key][1])*float(CBH2[key][0])

DH_reaz = (sumE_prod - sumE_reac - E) # DH of reaction
DH0_rung2 = -DH_reaz + (sumDH0_prod - sumDH0_reac) # DH0f

# Estimation of DH0f at rung 1 high level
if HL_computed:
    sumDH0_prod, sumDH0_reac, sumE_prod, sumE_reac = 0,0,0,0

    # Update counter for high level reactants, rung 2
    for key in CBH1:
        for keyhl in CBH1hl:
            if key == keyhl:
                CBH1hl[keyhl][0] = CBH1[key][0]
                break

    # Update counter for high level products, rung 2
    for key in CBH2:
        for keyhl in CBH2hl:
            if key == keyhl:
                CBH2hl[keyhl][0] = CBH2[key][0]
                break

    # Reactants sum of (Eel+ZPE) and sum of DH0f
    for key in CBH1hl:
        if CBH1hl[key][0] != 0:
            sumDH0_reac += float(CBH1hl[key][2])*float(CBH1hl[key][0])
            sumE_reac += float(CBH1hl[key][1])*float(CBH1hl[key][0])

    # Products sum of (Eel+ZPE) and sum of DH0f
    for key in CBH2:
        if CBH2hl[key][0] != 0:
            sumDH0_prod += float(CBH2hl[key][2])*float(CBH2hl[key][0])
            sumE_prod += float(CBH2hl[key][1])*float(CBH2hl[key][0])

    DH_reaz = (sumE_prod - sumE_reac - EHL) # DH of reaction
    DH0_rung2_HL = -DH_reaz + (sumDH0_prod - sumDH0_reac) # DH0f

# Update the reference species informations for level1 and hl
for key in CBH2:
    if CBH2[key][0] != 0:
        if float(CBH2[key][1]) > -100.0: line="{:<15}{:>5}".format(key, str(CBH2[key][1]))
        else: line="{:<14}{:>5}".format(key, str(CBH2[key][1]))
        if float(CBH2[key][2]) > 0: infos = infos+line +"    "+ str(CBH2[key][2]) +"\n"
        else: infos = infos+line +"   "+ str(CBH2[key][2]) +"\n"

if HL_computed:
    for key in CBH2hl:
        if CBH2hl[key][0] != 0:
            if float(CBH2hl[key][1]) > -100.0: line="{:<15}{:>5}".format(key, str(CBH2hl[key][1]))
            else: line="{:<14}{:>5}".format(key, str(CBH2hl[key][1]))
            if float(CBH2hl[key][2]) > 0: infoshl = infoshl+line +"    "+ str(CBH2hl[key][2]) +"\n"
            else: infoshl = infoshl+line +"   "+ str(CBH2hl[key][2]) +"\n"

# Construct list of SMILES not found in the reference data
missing_smiles = ""
if smilesnotfound != []:
    for i in range(len(smilesnotfound)):
        missing_smiles=missing_smiles+smilesnotfound[i]+"\n"

# Create directory thermo for output files
if not thermo_directory:
    os.mkdir("thermo")
    thermo_directory = True

# This part of the code computes the level compute the level1 file .out
# It is store in the subdirectory "thermo"
# Always computed, if the simulation is succesfull
# The numerical values of the highest rung estimation are saved in "output" for level1 and in "me_files" for high level

flag_error_l1 = True # Check for at least CBH0 at level1 computed

if flag_CBH2: # Rung 2 estimated correctly, all three CBH levels saved

    text = "Estimation of ΔH0f(0 K) with the Connectivity Based Hierarchy method\nLevel of theory/Basis set: "+str(lot_string)+"\n\n"+\
        "CBH0 rung reaction:\n"+reaction0+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung0)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung0*627.509)+" [kcal/mol]"+\
        "\n\nCBH1 rung reaction:\n"+reaction1+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung1)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung1*627.509)+" [kcal/mol]\n\n"+\
        "CBH2 rung reaction:\n"+reaction2+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung2)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung2*627.509)+" [kcal/mol]\n\n"+\
        "Sum of (Electronic energy + ZPE) "+smiles+": "+str(E)+" [Ha]\n"+\
        "Reference data:\n"+\
        "              Eel+ZPE [Ha]  ΔH0f(0 K) [Ha]\n"+infos

    value_DH0 = str(DH0_rung2*627.509)

elif flag_CBH1 and smilesnotfound == []: # Rung 1 estimated correctly, but too short molecule for rung 2. Up to rung 1 saved

    text = "Estimation of ΔH0f(0 K) with the Connectivity Based Hierarchy method\nLevel of theory/Basis set: "+str(lot_string)+"\n\n"+\
        "CBH0 rung reaction:\n"+reaction0+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung0)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung0*627.509)+" [kcal/mol]"+\
        "\n\nCBH1 rung reaction:\n"+reaction1+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung1)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung1*627.509)+" [kcal/mol]\n\n"+\
        "Sum of (Electronic energy + ZPE) "+smiles+": "+str(E)+" [Ha]\n"+\
        "Reference data:\n"+\
        "              Eel+ZPE [Ha]  ΔH0f(0 K) [Ha]\n"+infos

    value_DH0 = str(DH0_rung1*627.509)

elif flag_CBH1 and smilesnotfound != []: # Rung 2 not estimated due to lack of informations (no correct ref. species in database). Up to rung 1 saved

    text = "Estimation of ΔH0f(0 K) with the Connectivity Based Hierarchy method\nLevel of theory/Basis set: "+str(lot_string)+"\n\n"+\
        "CBH0 rung reaction:\n"+reaction0+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung0)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung0*627.509)+" [kcal/mol]"+\
        "\n\nCBH1 rung reaction:\n"+reaction1+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung1)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung1*627.509)+" [kcal/mol]\n\n"+\
        "WARNING: the CBH2 level can't be computed because the following species are not present in the database:\n"+\
        missing_smiles+"\n\n"+\
        "Sum of (Electronic energy + ZPE) "+smiles+": "+str(E)+" [Ha]\n"+\
        "Reference data:\n"+\
        "              Eel+ZPE [Ha]  ΔH0f(0 K) [Ha]\n"+infos

    value_DH0 = str(DH0_rung1*627.509)

elif flag_CBH0: # Rung 0 estimated correctly, but too short molecule for rung 1. Rung 0 saved

    text = "Estimation of ΔH0f(0 K) with the Connectivity Based Hierarchy method\nLevel of theory/Basis set: "+str(lot_string)+"\n\n"+\
        "CBH0 rung reaction:\n"+reaction0+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung0)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung0*627.509)+" [kcal/mol]\n\n"+\
        "Sum of (Electronic energy + ZPE) "+smiles+": "+str(E)+" [Ha]\n"+\
        "Reference data:\n"+\
        "              Eel+ZPE [Ha]  ΔH0f(0 K) [Ha]\n"+infos

    value_DH0 = str(DH0_rung0*627.509)

else: # No rung reaction computed -> Molecule is too short for CBH0
    text = "ERROR: fragment  "+smiles+"  ΔH0f(0 K) can't be computed with CBH method. Fragment's too short!"
    flag_error_l1 = False


if HL_computed: # The HL has been computed -> The DH0f can be estimated at this level from the HL theory fragments
    os.chdir("me_files")

    textHL = ""
    if flag_CBH2: # Rung 2 estimated correctly, all three CBH levels saved
        textHL = "Estimation of ΔH0f(0 K) with the Connectivity Based Hierarchy method\nLevel of theory/Basis set: "+str(lot_string)+"\n\n"+"CBH0 rung reaction:\n"+ \
            reaction0+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung0_HL)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung0_HL*627.509)+" [kcal/mol]\n\nCBH1 rung reaction:\n"+ \
            reaction1+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung1_HL)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung1_HL*627.509)+" [kcal/mol]\n\n"+\
            "CBH2 rung reaction:\n"+reaction2+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung2_HL)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung2_HL*627.509)+" [kcal/mol]\n\n"+\
            "Sum of (Electronic energy + ZPE) "+smiles+": "+str(EHL)+" [Ha]\n"+\
            "Reference data:\n"+\
            "              Eel+ZPE [Ha]  ΔH0f(0 K) [Ha]\n"+infoshl

        # Store value of estimated DH0f, at rung 2, in directory "me_files", in [kcal/mol]
        file_thermo = open("reac1_DH0K.me","w")
        file_thermo.write("  "+str(DH0_rung2_HL*627.509))
        file_thermo.close()

    elif flag_CBH1 and smilesnotfound == []: # Rung 1 estimated correctly, but too short molecule for rung 2. Up to rung 1 saved

        textHL = "Estimation of ΔH0f(0 K) with the Connectivity Based Hierarchy method\nLevel of theory/Basis set: "+str(lot_string)+"\n\n"+\
            "CBH0 rung reaction:\n"+reaction0+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung0_HL)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung0_HL*627.509)+" [kcal/mol]"+\
            "\n\nCBH1 rung reaction:\n"+reaction1+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung1_HL)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung1_HL*627.509)+" [kcal/mol]\n\n"+\
            "Sum of (Electronic energy + ZPE) "+smiles+": "+str(EHL)+" [Ha]\n"+\
            "Reference data:\n"+\
            "              Eel+ZPE [Ha]  ΔH0f(0 K) [Ha]\n"+infoshl

        # Store value of estimated DH0f, at rung 2, in directory "me_files", in [kcal/mol]
        file_thermo = open("reac1_DH0K.me","w")
        file_thermo.write("  "+str(DH0_rung1_HL*627.509))
        file_thermo.close()

    elif flag_CBH1 and smilesnotfound != []: # Rung 2 not estimated due to lack of informations (no correct ref. species in database). Up to rung 1 saved

        textHL = "Estimation of ΔH0f(0 K) with the Connectivity Based Hierarchy method\nLevel of theory/Basis set: "+str(lot_string)+"\n\n"+\
            "CBH0 rung reaction:\n"+reaction0+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung0_HL)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung0_HL*627.509)+" [kcal/mol]"+\
            "\n\nCBH1 rung reaction:\n"+reaction1+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung1_HL)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung1_HL*627.509)+" [kcal/mol]\n\n"+\
            "WARNING: the CBH2 level can't be computed because the following species are not present in the database:\n"+\
            missing_smiles+"\n\n"+\
            "Sum of (Electronic energy + ZPE) "+smiles+": "+str(EHL)+" [Ha]\n"+\
            "Reference data:\n"+\
            "              Eel+ZPE [Ha]  ΔH0f(0 K) [Ha]\n"+infoshl

        # Store value of estimated DH0f, at rung 1, in directory "me_files", in [kcal/mol]
        file_thermo = open("reac1_DH0K.me","w")
        file_thermo.write("  "+str(DH0_rung1_HL*627.509))
        file_thermo.close()

    elif flag_CBH0: # Rung 0 estimated correctly, but too short molecule for rung 1. Rung 0 saved

        textHL = "Estimation of ΔH0f(0 K) with the Connectivity Based Hierarchy method\nLevel of theory/Basis set: "+str(lot_string)+"\n\n"+\
            "CBH0 rung reaction:\n"+reaction0+"\nEstimated ΔH0f(0 K) = "+str(DH0_rung0_HL)+" [Ha]\nEstimated ΔH0f(0 K) = "+str(DH0_rung0_HL*627.509)+" [kcal/mol]\n\n"+\
            "Sum of (Electronic energy + ZPE) "+smiles+": "+str(EHL)+" [Ha]\n"+\
            "Reference data:\n"+\
            "              Eel+ZPE [Ha]  ΔH0f(0 K) [Ha]\n"+infoshl

        # Store value of estimated DH0f, at rung 0, in directory "me_files", in [kcal/mol]
        file_thermo = open("reac1_DH0K.me","w")
        file_thermo.write("  "+str(DH0_rung0_HL*627.509))
        file_thermo.close()

    else: # No rung reaction computed -> Molecule is too short for CBH0
        textHL = "ERROR: fragment  "+smiles+"  ΔH0f(0 K) can't be computed with CBH method. Fragment's too short!"

    # Store file with hl reactions at every rung computed in directory "thermo", in [kcal/mol]
    os.chdir("../thermo")
    file_thermo = open("hl_DH0K.out","w")
    file_thermo.write(textHL)
    file_thermo.close()
    os.chdir("..")

# Store file with level1 reactions at every rung computed in directory "thermo", in [kcal/mol]
os.chdir("thermo")
file_thermo = open("DH0K.out","w")
file_thermo.write(text)
file_thermo.close()
os.chdir("..")

if flag_error_l1: # Check if level1 has at least a rung0 estimation. If not, no output value is written in "output"

    # Store value of estimated DH0f, at the highest rung computed, in directory "output", in [kcal/mol]
    os.chdir("output")
    value = open("reac1_DH0K.out","w")
    value.write("  "+value_DH0)
    value.close()
    os.chdir("..")
